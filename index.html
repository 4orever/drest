---
layout: default
title: Drest Documentation
---

<div class="page-header" style="margin: 0px">
  <h1>Dress up your doctrine entities</h1>
  <h3>- and expose them as RESful resources</h3>  
  <p style="margin: 0px">This library allows you to quickly annotate your doctrine entities into restful resources. 
    It comes shipped with it's own internal router, and can be used standalone or alongside your existing framework stack.
    Routes are mapped to either a default or customised service action that takes care of handling requests.<br><br>      
    </p>
</div>
<h4>Features:</h4>
<h5>- Quickly annotate existing Doctrine entities to become a fully functional REST resource.</h5>
<pre>@Drest\Resource(
    routes={
        @Drest\Route(
            name="get_user",
            route_pattern="/user/:id",
            verbs={"GET"}
)})</pre>
<h5>- Utilises the internal router for matching resource route patterns.</h5>
<pre>
[GET] http://myapplication.com/api/user/123
</pre>
<h5>- Specify what data you want to expose from your entities (including relations), or let the client choose! <a href="#" class="show_hide">(see code)</a></h5>
<pre>
// Set exactly what fields you want to expose
@Drest\Route(
    expose={"username", "profile" : {"id", "lastname", "addresses" : {"address"}}, "phone_numbers"}
 )
 
 // or let the client choose
$config->setExposeRequestOption(Configuration::EXPOSE_REQUEST_PARAM_GET, 'expose');

[GET] http://myapplication.com/api/user/123?expose=username|profile[id, lastname]

// Also you can set a specific maximum depth you want to expose - (uses doctrines relations)
$config->setExposureDepth(3);</pre>
<h5>- Generate data objects using exposable data for your API users to consume. <a href="#" class="show_hide">(see code)</a></h5>
<pre>
// Generate data classes to interact with
php drest-client.php classes:generate --dest-path="/path/for/SomeApi" --namespace="SomeApi" http://yourapi.endpoint

Generating client classes....
Successfully wrote client class "/path/for/SomeApi/Entities/Address.php"
Successfully wrote client class "/path/for/SomeApi/Entities/Profile.php"
Successfully wrote client class "/path/for/SomeApi/Entities/PhoneNumber.php"
Successfully wrote client class "/path/for/SomeApi/Entities/User.php"

Client classes have been sucessfully generated at "/path/for/SomeApi"
--------------------------------------------------------------------------

// Your users can then start operating on them using the client tool
$client = new Drest\Client('http://yourapi.endpoint', 'Json');

$user = SomeApi\Entities\User::create()
        ->setEmailAddress('hello@somewhere.com')
        ->setUsername('leedavis81')
        ->setProfile(Client\Entities\Profile::create()
            ->setTitle('mr')
            ->setFirstname('lee')
            ->setLastname('davis'))
        ->addPhoneNumbers(array(
            Client\Entities\PhoneNumber::create()->setNumber('02087888888'),
            Client\Entities\PhoneNumber::create()->setNumber('07515788888')))
        ->addPhoneNumber(Client\Entities\PhoneNumber::create()->setNumber('07953788888'));

try
{
    $response = $client->post('/user', $user);
    if (($location = $response->getHttpHeader('Location')) !== null)
    {
        echo 'The resource was created at: ' . $location;
    }
} catch (\Drest\Error\ErrorException $e)
{
    echo $e->getErrorDocument()->render();
}

</pre>
<h5>- Comes shipped with both JSON and XML representations, or you can create your own. <a href="#" class="show_hide">(see code)</a></h5>
<pre>
// Set the default representations to be used
$config->setDefaultRepresentations(array('Json', 'Xml'));

// Or only allow certain representations per resource
 @Drest\Resource(
    representations={"Json"}
    .....
)</pre>
<h5>- Allows media type detection from your client requests, getting you one step close to RMM level 3. <a href="#" class="show_hide">(see code)</a></h5>
<pre>
// Determine the requested media type by reading:
$drestConfig->setDetectContentOptions(array(
    Configuration::DETECT_CONTENT_HEADER => 'Accept',   // An HTTP Header called "Accept"  
    Configuration::DETECT_CONTENT_EXTENSION => true,    // A dot extension on the URL (eg .json)
    Configuration::DETECT_CONTENT_PARAM => 'format'     // A parameter parsed called "format" (eg format=xml)
));</pre>
<h5>- Use it independently from your existing framework stack, or alongside it*. <a href="#" class="show_hide">(see code)</a></h5>
<pre>
// Dispatch from an application endpoint (index.php)
echo $dm->dispatch();

// Or from within a controller in your framework
$updatedResponseObject =  $dm->dispatch($myZf2RequestObject, $mySym2ResponseObject);

// Or call an exact route by name (bypasses routing)
$updatedResponseObject =  $dm->dispatch(null, $myResponseObject, 'Entities\User::get_users');
</pre>
<p>* On the condition that both request / response adapters have been created for that particular framework.</p>
<h5>- Allows extension points so you can configure requests to your specific needs. <a href="#" class="show_hide">(see code)</a></h5>        
<pre>
 @Drest\Resource(
    routes={
        @Drest\Route(
            name="get_user",
            route_pattern="/user/:id+",
            verbs={"GET"},
            action="Action\Custom"
 )})
 
namespace Action;

class Custom extends \Drest\Service\Action\AbstractAction
{
    /*
     * From here you'll have access to the following objects via the service property. ie $this->service->get*
     * 
     * @var \Doctrine\ORM\EntityManager                     $em                 - Doctrine Entity Manager
     * @var \Drest\Manager                                  $dm                 - Drest Manager
     * @var \Drest\Request                                  $request            - Drest Request Object
     * @var \Drest\Response                                 $response           - Drest Response Object
     * @var \Drest\Mapping\RouteMetaData                    $route              - The mathced route
     * @var \Drest\Representation\AbstractRepresentation    $representation     - The pre-determined media representation
     */
    public function execute()
    {
        // .. execute my own logic, return a custom result set ..
         return ResultSet::create(array('name' => 'lee', 'email' => 'lee@somedomain.com'), 'user');
    }
}
</pre>
<p>Note that the full namespace to the cusom plugin class must be provided in the annotations. You may need to include your custom class files, or setup an autoloader for them.</p>